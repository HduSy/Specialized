Created Date：2022-12-17 21:12:54  
Last Modified：2022-12-17 21:12:53

# Tags

#前端工程化

# Content

<<<<<<< HEAD
## 包管理工具

### Npm

## 配置文件说明 package.json

### Type

指明文件为哪种模块处理方式。`require/module.exports` 的 `Node commonjs` 模块还是 `import/export` 的 `ECMAScript module` 模块处理。

三点说明：  
1、建议始终不要忽略，虽然默认是 `commonjs` 规范；  
2、指明了 `.js` 和无扩展名文件处理方式；  
3、不受 `type` 影响的两种类型文件，`.mjs` 的文件都按照 `ES` 模块来处理，`.cjs` 的文件都按照 `commonJs` 模块来处理；

### Files

（可选）文件数组，列出安装该依赖时会包括的条目，忽略时将包含所有文件。

```
以下文件无论是否设置，总是包含：

package.json
README
CHANGES/CHANGELOG/HISTORY
LICENSE/LICENCE
NOTICE

以下文件总是被忽略：
.git
CVS
.svn
.hg
.lock-wscript
.wafpickle-N
.*.swp
.DS_Store
._*
npm-debug.log
.npmrc
node_modules
config.gypi
*.orig
package-lock.json
```

### Main

（可选）主入口文件，默认 `index.js`。

### Browser

当依赖作为客户端浏览器使用时，应使用 `browser` 替代 `main`，告诉用户可能包含 `node` 环境不支持的用法。

### Bin

提供的内部命令对应可执行文件位置。

### Private

`npm publish` 拒绝发布，防止意外发布到开源社区。

### Repository

代码仓库地址。

### Scripts

命令行 `npm` 脚本缩写。

### Config

添加命令行环境变量。

### Dependencies

通过 `npm install --save` 命令安装依赖。

`Please do not put test harnesses or transpilers or other "development" time tools in your dependencies object.`  

不要把测试、开发用依赖安装到 `dependencies`。

### devDependencies

通过 `npm run install --save-dev` 命令安装依赖。

### Engines

项目以来 `node` 版本。

## package.lock.json 作用

### 参考链接

[npm 依赖管理中被忽略的那些细节_语言 & 开发_政采云前端团队_InfoQ精选文章](https://www.infoq.cn/article/qj3z2ygrzdgicqauaffn)

### 总结

1. 锁定版本号，始终保证各团队成员、CI 安装同一份完全相同的依赖树；
2. 通过 Git 版本管理工具，清晰查看 diff 从而掌握依赖树变动；
3. 不必提交整个 node_modules 文件夹，通过 packge.lock.json 即可保证依赖树相同；
4. 跳过已安装包，优化安装过程。

## 见过的 Npm 包

开发 CLI 脚手架必备 [commander.js](https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md)

Node 环境下 Json 文件读写 [node-jsonfile](https://github.com/jprichardson/node-jsonfile)

终端字体样式设置 [chalk](https://github.com/chalk/chalk)

终端进度转轮提示 [ora](https://www.npmjs.com/package/ora)

验证是否合法 Npm 包名 [validate-npm-package-name](https://github.com/npm/validate-npm-package-name)

命令行交互 [inquirer](https://github.com/SBoudrias/Inquirer.js)

下载一个 Git Repo [download-git-repo](https://www.npmjs.com/package/download-git-repo)

CssInJsReact 实践 [styled-components](https://styled-components.com/docs/basics)

[px2rem](https://www.npmjs.com/package/px2rem)

Postcss Flex 布局下 Bug 修复补丁 [postcss-flexbugs-fixes](https://www.npmjs.com/package/postcss-flexbugs-fixes)

```js postcss.config.js
module.exports = {  
  plugins: [  
    require('autoprefixer')(),  
    require('postcss-flexbugs-fixes')(),  
    require('postcss-px2rem')({  
      remUnit: 100,  
    }),  
  ],  
};
```

Zip 压缩方案 [压缩解压缩 zip 到本地disk or 内存 buffer](https://github.com/cthackers/adm-zip)

获取 .md 类型文件 MD5 值 [md5-file](https://www.npmjs.com/package/md5-file)

Glob 语法快速遍历文件系统，支持模式匹配，返回文件路径名 [fast-glob](https://github.com/mrmlnc/fast-glob)

使用 Glob 语法删除文件/文件夹 [del](https://www.npmjs.com/package/del)

VSCODE 代码编辑器 [monaco-editor](https://github.com/microsoft/monaco-editor)

ORM 框架，方便操作数据库 [typeorm](https://typeorm.bootcss.com/)

Nodejs 压缩中间件 [compression](https://www.npmjs.com/package/compression)

Nodejs Cookie 中间件 [cookie-parser](https://www.npmjs.com/package/cookie-parser)

可读性好的 Api 创建 Schema 描述文件验证对象结构 [joi](https://joi.dev/)

普通对象与类实例间相互转换 [class-transformer](https://www.npmjs.com/package/class-transformer)

基于装饰器的类型验证 [class-validator](https://www.npmjs.com/package/class-validator)

React Router [react-router-dom](https://v5.reactrouter.com/web/guides/quick-start)  

将指定 `.env` 文件中的配置加载到环境变量 `process.env` 中。[dotenv](https://github.com/motdotla/dotenv)

`nodejs spawn` 跨平台解决方案 [cross-spawn](https://www.npmjs.com/package/cross-spawn) 自动根据操作系统平台决定是否起一个 `shell` 来执行当前 **系统命令**。

`jss` [css in js lib](https://cssinjs.org/)  

`intersection-observer` [polyfill for intersection-observer](https://www.npmjs.com/package/intersection-observer)

`fs-extra` 替换 `fs`，提供更多方法（同步/异步），且支持 promise  

`dotenv` 将 `.env` 文件中的配置加载到 `process.env` 上  

`cross-env` 跨操作系统平台，设置 `NODE_ENV`  
`humps` 驼峰转换

## 升级

### Yarn

### Lerna

#### 描述

`monorepo: lerna + yarn`  

[使用](https://segmentfault.com/a/1190000023059277)

### Pnpm

#### 描述

#### 提升

1、优化磁盘空间  
2、大幅提升下载速度

#### 命令

##### 等同于 Npx 功能

`pnpm dlx <pkg_name> [options]`

##### 本地免发布调试开发中的 Npm 包

`pnpm link <dir>`：指定 `dir` 目录下软件包链接到当前目录下 `node_modules` 目录中；

`pnpm link --global`：将当前工作目录或 `--dir` 参数指定目录下软件包链接到全局环境 `node_modules` 目录中；

`pnpm link --global [pkg-name]`：将全局环境 `node_modules` 目录中指定软件包链接到当前工作目录下；

### Yarn

#### Resolution

关于 `package.json` 中 `resolutions` 的配置项使用，[resolutions 替换二进制文件镜像地址](https://segmentfault.com/a/1190000021168459)，一些二进制文件并不能通过修改源地址为镜像地址来规避，而且自主编译的成功率也低得多，也就是说通过这种方式 yarn、npm 拿它也没办法。查看源码，会发现安装完后额外使用二进制文件编译的模块多使用 [bin-wrapper](https://www.npmjs.com/package/bin-wrapper) 执行下载和编译。如 `pngquant-bin`：

```javascript install.js
'use strict';  
const path = require('path');  
const BinWrapper = require('bin-wrapper');  
const pkg = require('../package.json');  
  
const url = `https://raw.githubusercontent.com/imagemin/pngquant-bin/v${pkg.version}/vendor/`;  
  
module.exports = new BinWrapper()  
 .src(`${url}macos/pngquant`, 'darwin')  
 .src(`${url}linux/x86/pngquant`, 'linux', 'x86')  
 .src(`${url}linux/x64/pngquant`, 'linux', 'x64')  
 .src(`${url}freebsd/x64/pngquant`, 'freebsd', 'x64')  
 .src(`${url}win/pngquant.exe`, 'win32')  
 .dest(path.resolve(__dirname, '../vendor'))  
 .use(process.platform === 'win32' ? 'pngquant.exe' : 'pngquant');
```

于是乎，如果在这之前，把下载地址替换成镜像地址，问题便迎刃而解了。[bin-wrapper-china](https://github.com/best-shot/bin-wrapper-china) 的解决思路就是如此。配合 `yarn` 的 `resolutions` 功能，安装时指定特定模块。

```json package.json
"resolutions": {  
  "bin-wrapper": "npm:bin-wrapper-china"  
}
```

### Pnpm

#### 介绍

##### 项目初衷

节省磁盘空间；提升安装速度。

- 依赖被安装在基于内容寻址的存储中，不存在多个重复拷贝；
- 依赖项不同版本的包，只会将差异文件添加到仓库；
- 依赖文件会存储到磁盘某一位置，安装已有依赖会硬链接到这一位置，不占用额外磁盘空间。

##### 创建非扁平化 node_modules 目录结构

诀窍一：node 会解析符号连接，如 `.pnpm/express@4.17.1/node_modules/express` 去寻找依赖真正所在位置。`.pnpm/` 文件夹（虚拟存储目录）中平铺着依赖，解决了 `npm v2` 依赖长路径问题，同时避免 `npm v3+` 及 `yarn v1` 安全问题，保留了包之间的隔离；

诀窍二：依赖包与依赖项的实际位置位于同一目录级别，比如 `express` 依赖项都存放在 `.pnpm/express@4.17.1/node_modules` 下，与 `express` 同级，避免了循环软链。

> [!info]+  
`peer` 依赖会特殊点处理…

##### 基于符号链接的 node_modules 结构

pnpm 的 `node_modules` 布局使用符号链接来创建依赖项的嵌套结构，只有真正在依赖项中的包才能访问。当你安装依赖后，pnpm 将在 `node_modules` 创建依赖对应硬链接。

=======
>>>>>>> 681c75e (fix: fatal cant read)
## 代码风格规范

[[../NPM 包/prettier]]  
[[../NPM 包/stylelint]]

## 代码编码规范

[[../NPM 包/Eslint]]

## git 规范

[[../NPM 包/husky]]  
[[../NPM 包/commitizen]]  
[[../NPM 包/lint-staged]]

## 语言支持

[[../JavaScript/模块化]]

# Reference

<<<<<<< HEAD
1. [2222 年了，总不能还只会 npm i 吧?🔥](https://juejin.cn/post/7069701706606444551)  
2. [前端工程化之强大的glob语法](https://juejin.cn/post/6876363718578405384)
3. [pnpm使用详细纤细说明/浏览26301/点赞361](https://juejin.cn/post/7053340250210795557)  
4. [npm 官网关于 package.json 详细字段说明](https://docs.npmjs.com/cli/v8/configuring-npm/package-json)
5. [pnpm 中文官网](https://www.pnpm.cn/)
6. [一个pnpm安装express目录结构的参考](https://github.com/zkochan/comparing-node-modules/tree/master/pnpm5-example)
=======
[前端工程化之强大的glob语法](https://juejin.cn/post/6876363718578405384)
>>>>>>> 681c75e (fix: fatal cant read)
