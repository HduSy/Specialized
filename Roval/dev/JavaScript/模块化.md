Created Date：2022-12-17 21:44:48  
Last Modified：2022-12-17 21:44:48

# Tags

#工程化

# Content

## IIFE

### demo

```js
// module-a.js
(function () {
  let data = "moduleA";

  function method() {
    console.log(data + "execute");
  }

  window.moduleA = {
    method: method,
  };
})();
```

### 特点

立即执行函数表达式。`IIFE` 创建了一个**私有作用域**，内部变量外界无法访问，只有内部函数才能访问，相比于命名空间更加安全。

### 优缺点

解决了全局声明变量的==命名冲突和作用域不明确问题==并没有解决==模块加载问题==，如果模块之间相互依赖则要对 `script` 加载顺序有严格限制否则会出现运行时 `bug`

## CommonJS

业界最早正式提出的 `JavaScript` 模块规范，主要用于 `NodeJS` 服务端：

- 定义了一套完整的模块化代码规范；
- `Node.js` 为该规范实现了自动加载模块的加载器 (也称 `loader`) ；

### 特点

- 文件即模块，代码运行在模块作用域，不会污染全局作用域；
- 相比 `ESM` 输出值的引用，`CommonJS` 输出值的拷贝；
- `require` 导入模块，`module.exports` 导出模块。`require` 引入 `module.exports` 对象的引用（值拷贝，浅拷贝，栈地址）；
- `CommonJS` 是**运行时加载，同步加载**，模块加载顺序按照代码中出现的顺序，`require` 时才去加载模块，`ESM` 是编译时输出接口；
- 模块加载一次后会被缓存，解决循环引用问题；  

### 加载过程

1. 优先从缓存中加载；
2. 如果缓存中没有，检查是否是核心模块，如果是直接加载；
3. 如果不是核心模块，检查是否是文件模块，解析路径，根据解析出的路径定位文件，然后执行并加载；
4. 如果以上都不是，沿当前路径向上逐级递归，直到根目录的 `node_modules` 目录。  

### 分析

运行时同步加载，放在服务端没什么问题，==一来文件都在本地不需要网络 IO，二来只有服务启动时才会加载模块，而服务通常在启动后一直运行了，所以对服务的性能无太大影响。==而放在浏览器端，大量同步模块请求阻塞 JS 解析过程

优点：

- 很多工具系统和包都是使用 `CommonJS` 构建的；
- 有着 `Node.js` 运行时环境支持；
- 使用简单；

缺点：

- 可以在 `JavaScript` 文件中包含一个模块；
- 同步加载，不适合浏览器环境；
- `loader` 由 `Nodejs` 提供，依赖 `Node.js` 本身的功能，如果想在 Web 浏览器中使用它，则需要额外的工具（第三方提供 `loader`，如 [browserify](https://github.com/browserify/browserify)）；

## AMD

`Asynchronous Module Definition` 异步模块定义，在浏览器环境中会被异步加载。在 `AMD` 规范当中，我们可以通过 `define` 去**定义或加载**一个模块，如果模块需要**导出**一些成员需要通过在定义模块的函数中 `return` 出去。如果当前模块依赖了一些其它的模块则可以通过 `define` 的**第一个参数来声明依赖**，这样模块的代码执行之前浏览器会**先加载依赖模块**

### demo

```js
// main.js
define(["./print"], function (printModule) {
  printModule.print("main");
});
​
// print.js
define(function () {
  return {
    print: function (msg) {
      console.log("print " + msg);
    },
  };
});
```

### 分析

优点：  

- 异步加载，更快的启动速度  
- 能够将模块拆分为多个文件；
- 支持构造函数；
- 无需额外工具即可在浏览器中工作  

缺点：

- 浏览器原生不支持，需借助第三方 `Loader` 如 `requireJS` 库来使用 `AMD`
- 语法阅读、书写都较为复杂，学习成本高

## CMD

`Common Module Definition`，通用模块定义，整合了 `CommonJS` 与 `AMD` 的特点，淘宝出品 `seajs` 是 `CMD` 规范的一个实现

### demo

```js
// 定义
// 使用 exports 直接向外提供接口。
define(function(require, exports) { 
    // 对外提供 name属性
    exports.name = 'Tom'; 
    // 对外提供 say 方法
    exports.say= function(name) {
        console.log("hello"+name)
    };
});
// 使用 return 直接向外提供接口。
define(function(require) {  
    return {
        name : 'Tom',    
        say: function(name) {
            console.log("hello"+name)
        }
    };
});
// 使用 module.exports 直接向外提供接口。
define(function(require, exports, module) { 
    module.exports = {
        name: 'Tom', 
        say: function(name) {
            console.log("hello"+name)
        }
    };
});
// 使用
define(function (require) {
    var m1 = require('./module1')
    console.log(m1.name)      // Tom
    m1.say(m1.name)           // Hello Tom
})
// require.async 方法用来在模块内部异步加载模块，并在加载完成后执行指定回调。callback 参数可选。
define(function(require, exports, module) {  
    // 异步加载一个模块
    require.async('./module1', function(a) {
        a.doSomething();
    }); ​
    // 异步加载多个模块，在加载完成时，执行回调
    require.async(['./module2', './module3'], function(b, c) {
        b.doSomething();
        c.doSomething();
    });
})
```

### 特点

优点：

- 懒加载，无需在定义模块的时候声明依赖，可以在模块执行时动态加载依赖
- 除此之外，`CMD` **同时支持**同步加载模块和异步加载模块  

缺点：

- 依赖 SPM 打包
- 模块的加载逻辑偏重

### 与 AMD 区别

- `AMD` 异步，`CMD` 同步、异步
- `CMD` 遵循依赖就近原则（具体代码逻辑内，使用依赖前），`AMD` 遵循依赖前置原则（`AMD` 则需要在第一个参数中列出所有前置依赖），提前 `define`

## UMD

`Universal Module Difinition`，通用模块定义，并不算一个新的规范，也是兼容 `AMD` 和 `CommonJS` 的一个模块化方案（`CMD` 同样如此），可以**同时运行在浏览器和 Node.js 环境**

```ad-note
在 ` Node.js` 环境中采用 `CommonJS` 模块管理，在浏览器环境且支持 `AMD` 的情况下采用 `AMD` 模块，否则导出为==全局函数==
```

### 组成

- **立即调用函数表达式 (IIFE)**：它会检查使用模块的环境。其有两个参数：`root` 和 `factory`。 `root` 是对全局范围的 `this` 引用，而 `factory` 是定义模块的函数
- **匿名函数：** 创建模块，此匿名函数被传递任意数量的参数以指定模块的依赖关系

### 执行过程

1. 先判断是否支持 `Node.js` 模块格式（`exports` 是否存在），存在则使用 `Node.js` 模块格式；
2. 再判断是否支持 `AMD`（`define` 是否存在），存在则使用 `AMD` 方式加载模块；
3. 若两个都不存在，则将模块公开到全局（`Window 或 Global`）

## ES Module

### 特点

`ES6 Module` 也被称作 `ES Module`(或 `ESM`)， 是由 `ECMAScript` 官方提出的模块化规范，作为一个官方提出的规范，`ES Module` 已经得到了现代浏览器的内置支持

浏览器遇到带 `type="module"` 的 `script` 标签，将按照 `ESM` 规范进行依赖加载和解析（`Vite` 开发阶段 `no-bundle` 原因，模块加载任务交给了浏览器，即使不打包也可以顺利运行模块代码）

优点：

- 作为标准，浏览器支持覆盖率高，`ESM` 拥有天然跨平台能力
- 兼容 `node` 环境，`Node.js` 也从 `12.20` 起正式支持了 `ESM`；  
- `import` 导入，`export` 导出。`import` 存在静态分析、提升，优先执行；
- 可以和 `CommonJS` 模块一起使用；  

缺点：

### 与 CommonJS 区别

- `ESM` 输出对外接口，是一种静态定义，在代码静态解析阶段就会生成；`CommonJS` 输出值的拷贝；
- 编译时执行，`JS` 引擎会做静态分析，先将模块加载完再执行；`CommonJS` 运行时加载；
- 无论是 `ES6` 模块还是 `CommonJS` 模块，当你重复引入某个相同的模块时，模块只会执行一次；

### 动态导入与静态导入

静态导入：模块须下载并执行完，然后主代码才可执行（预先加载）；  
动态导入：按需加载，提高初始加载性能

```html
<script type="module">
  (async () => {
    const moduleSpecifier = './lib.mjs';
    const {repeat, shout} = await import(moduleSpecifier);
    repeat('hello');
    // → 'hello hello'
    shout('Dynamic import in action');
    // → 'DYNAMIC IMPORT IN ACTION!'
  })();
</script>
```

### 整体加载

```js
import * as chalk from 'chalk'

chalk.white.bold('[INFO]')
chalk.yellow.bold('[WARN]')
chalk.green.bold('[SUCCESS]')
chalk.red.bold('[ERROR]')
```

### 默认导出

## Pure ESM

## tsup 新一代的基础库打包器

主打无配置 (no config) 打包，轻易地打出 `ESM` 和 `CommonJS` 双格式的产物，本身利用 `ESbuild` 进行打包，性能非常强悍，也能生成类型文件

# Reference

[前端模块化规范 - 专业汇总](https://jonny-wei.github.io/blog/devops/vite/esm.html)  
[前端模块导入导出规范之ESM与CommonJs](https://juejin.cn/post/6970296913039999007)  
[Pure ESM package](https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c)
