Created Date：2024-01-09 11:51:37  
Last Modified：2024-01-09 11:51:37

# Tags

#前端 #缓存

# Content

## 流程

![[Pasted image 20240109135827.png]]

## 缓存优缺点

### 优点

- 缓解服务器压力
- 提升页面加载速度
- 离线访问

### 缺点

- 更新

## 浏览器缓存（本地缓存）

### Service Worker

是一个**离线缓存**，特点：

1. 运行在 **worker 上下文**，因此它不**能访问 DOM**；
2. **独立于主线程**之外，不会造成阻塞；
3. 设计完全**异步**，所以同步 `API`（如 `XHR` 和 `localStorage` ）不能在 `Service Worker` 中使用；
4. 出于安全考虑，必须在 **HTTPS 环境**下才可以使用；
5. 允许开发者自己操控缓存，缓存哪些文件、如何匹配缓存、如何读取缓存

### Memory Cache

内存缓存，存储在浏览器内存。**优点**：速度快、优先级高，从内存中获取资源耗时为 0 ms；**缺点**：生命周期短，大小有限；存储图像和网页中的资源 `js css img`

### Dist Cache

磁盘缓存，存储在计算机硬盘。**优点**：生命周期长，不删除则一直存在；**缺点**：速度相对内存缓存要慢；存储图像和网页中的资源 `js css img`

#### 内存 or 磁盘

1. 对于大文件来说，大概率是不存储在内存中的，反之优先；
2. 当前系统内存使用率高的话，文件优先存储进磁盘；

### Push Cache HTTP/2

```ad-info
查找浏览器缓存时会按顺序查找: Service Worker-->Memory Cache-->Disk Cache-->Push Cache
```

特点：

1. 以上三种均为命中时才会被使用；
2. 只在会话中存在，生命周期短暂，`Chrome` 中只有 `5min` 左右
3. 并非严格执行 HTTP 头中的缓存指令

### Cookie

存储空间很小，不能超过 **4KB**，且操作原生 `Cookie API` 也不方便，建议使用第三方封装好的工具，不适合拿来存储大量数据

应用：验证用户身份及维持状态；  

### H5 Web Storage

支持**2.5-10M**，存储的数据最终都会转化成**字符串类型**，因此对于对象数据要进行 `JSON.stringify JSON.parse` 序列化、反序列化操作

```js
let userinfo = { name: 'wentang', age: 18 }

// 存储时进行序列化操作
localStorage.setItem('userinfo', JSON.stringify(userinfo))

// 获取时进行反序列化操作
JSON.parse(localStorage.getItem('userinfo'))

```

#### sessionStorage

生命周期存在于网页会话期间，网页关闭后会自动释放

#### localStorage

存储于浏览器本地，除非手动删除或过期，否则其一直存在，属于持久性缓存

### indexedDB

支持大小**250M**，大规模的 NoSQL 存储系统，它几乎可以存储浏览器中的任何数据内容

### Cache API

## HTTP 缓存

### 强缓存

不会向服务器发送请求，直接从缓存中读取资源，响应码 **200**  

首次请求资源若服务器**响应头**有 `Expires` 或 `Cache-Control` 标识，代表这是强缓存，浏览器就会把资源缓存在 memory cache 或 disk cache 中；  
二次请求时浏览器判断标识，若符合强缓存条件直接从本地缓存中拿数据，响应吗 **200**；

#### Expires HTTP1.0

时间戳，一个绝对时间，利用本地时间与其比较，超过这个时间重新请求。

缺点是本地时间用户可修改，不可靠

#### Cache-Control HTTP1.1

- public：客户端和代理服务器都可以缓存；
- private：资源只能被客户端缓存；
- **no-cache**：不使用强缓存，使用协商缓存；
- **no-store**：不使用缓存；
- max-age：**相对时间**，单位为**秒数**，`Expires` 同时出现时，`max-age` 的优先级更高，解决了 `Expires` 的问题；
- s-maxage：决定了代理服务器缓存的时长，必须和 `public` 属性一起使用；

### 协商缓存

协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。

#### Last-Modified 与 If-Modified-Since

首次请求时服务器响应头返回 `Last-Modified`，而浏览器在后续请求时请求头带上其值作为 `If-Modified-Since`，服务器收到 `If-Modify-Since` 后，根据资源的最后修改时间判断是否命中缓存，如果命中缓存，则返回 304，并且不会返回资源内容，并且**不会返回**`Last-Modify`

```ad-warning
只能精确到秒级，1s内文件修改多次或文件修改和请求发生在1s内时，无法正确标注文件修改时间，即短时间内资源发生了改变，`Last-Modified`并不会发生变化
```

#### ETag 与 If-None-Match

资源变化都会导致 `ETag` 变化，解决上述缓存标识问题

#### 对比

- 精确度上，`Etag > Last-Modified`；
- 性能上，`Etag < Last-Modified`，毕竟 `Last-Modified` 只需要记录时间，而 `Etag` 需要服务器通过算法来计算出一个 `hash` 值；
- 优先级上，`Etag > Last-Modified`；

#### 应用

1. 如果什么缓存策略都没设置，浏览器会采用一个**启发式**的算法，通常会取响应头中的 **Date 减去 Last-Modified 值的 10%** 作为缓存时间；
2. 对于**频繁变动**的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小（**协商缓存**）；
3. **不常变化**的资源，给它们的 `Cache-Control` 配置一个很大的 `max-age=31536000` (一年)，这样浏览器之后请求相同的 URL 会命中**强缓存**；

# Reference

[浏览器\-浏览器缓存机制相关 \- 糖羽仙](https://www.tangyuxian.com/2022/06/30/%E5%89%8D%E7%AB%AF/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3/)
