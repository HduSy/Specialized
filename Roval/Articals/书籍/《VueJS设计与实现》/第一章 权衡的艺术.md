Created Date：2023-12-19 10:38:13  
Last Modified：2023-12-19 10:38:12

# Tags

[[../../../dev/NPM/Vue2|Vue2]] [[../../../dev/NPM/Vue3|Vue3]] [[../../../前端面经/Vue面经|Vue面经]]

# Content

## 1.1 命令式与声明式

视图层框架通常分为**命令式**和**声明式**。  

1. 命令式框架更加**关注过程**，自然语言描述能够与代码一一对应，代码本身描述的是“做事的过程”，符合我们的逻辑直觉；
2. 声明式框架则**关注结果**，至于实现结果的过程是怎样的，我们并不关心；

```js
// 命令式
const div = document.querySelector('#app') // 获取 div
div.innerText = 'hello world' // 设置文本内容
div.addEventListener('click', () => { alert('ok') }) // 绑定点击事件

// 声明式 Vue：嘿，Vue.js，看到没，我要的就是一个 div，文本内容是 hello world，它有个事件绑定，你帮我搞定吧。
<div @click="() => alert('ok')">hello world</div>
```

## 1.2 性能与可维护性权衡

更新文本命令式代码与声明式代码写法差别：

```js
// 命令式
div.textContent = 'hello vue3' // 直接修改
// 声明式
<!-- 之前： -->
<div @click="() => alert('ok')">hello world</div>
<!-- 之后： -->
<div @click="() => alert('ok')">hello vue3</div>
```

对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是：

```js
div.textContent = 'hello vue3'
```

A：直接修改的性能消耗；B：找出差异的性能消耗；则：

- 命令式代码更新性能消耗 = **A**
- 声明式代码更新性能消耗 = **B + A**  

**理想情况**下将 B 降到接近于 0 时，声明式与命令式代码性能消耗相同。

**框架本身封装了命令式代码才向用户提供了声明式，声明式代码的性能不优于命令式代码的性能**。但是声明式代码**可维护性更强，更加直观**，不必像命令式代码那样要维护整个过程，手动完成创建、更新、删除等工作。

框架设计者要做的就是：在保证可维护性的前提下，尽量最小化性能损耗

## 1.3 虚拟 DOM 的性能到底如何

1.2 节提到，声明式代码更新时性能损耗 = B + A，虚拟 DOM 就是为了**最小化 B** 而出现的。 采用虚拟 DOM 更新技术的性能*理论上*不可能比原生 `JavaScript` 操作 DOM 高，因为绝大多数情况下写不出绝对优化的命令式代码。

**纯 JavaScript 层面的操作要比 DOM 操作快得多，它们不在一个数量级上。**

### 创建阶段

虚拟 DOM ：

1. 创建 JavaScript 对象，对真实 DOM 进行描述；
2. 递归地遍历虚拟 DOM 树并创建真实 DOM；  

**创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量**  

![[Pasted image 20231219111257.png]]  

innerHTML ：

1. 构造一段 HTML 字符串；
2. 赋值给 innerHTML 时，将 HTML 字符串解析为 DOM 树（DOM 层面的计算；

**HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量**

|            | 虚拟 DOM | innerHTML |
| ---------------- | ------- | --------- |
| 纯 JavaScript 计算 |   创建 JavaScript 对象 (VNode)      |     渲染 HTML 字符串      |
| DOM 层面计算                 |     新建所有 DOM 元素    |        新建所有 DOM 元素   |

### 更新阶段

innerHTML：重新构建 HTML 字符串，重新设置 innerHTML 等价于**销毁所有旧的 DOM，再全量创建新的 DOM**；  
虚拟 DOM：重新创建 JavaScript 对象（虚拟 DOM 树），**比较新旧虚拟 DOM，找出变化的元素并更新**；  

|                    | 虚拟 DOM                        | innerHTML                            |
| ------------------ | ------------------------------- | ------------------------------------ |
| 纯 JavaScript 计算 | 创建新的 JavaScript 对象 + diff | 渲染新的 HTML 字符串                 |
| DOM 层面计算       | 必要的 DOM 更新                 | 全量更新！销毁所有旧的，新建所有新的 |
| 性能影响因素       | 与数据变化量相关（无论页面多大只更新变化的内容                | 与页面大小相关（页面越大性能损耗越大                                     |

### 总结

从心智负担、可维护性、性能三方面比较：

![[Pasted image 20231219112721.png]]

## 1.4 运行时和编译时

### 纯运行时 Render

用户为 `Render` 函数提供**树形结构的数据对象（虚拟 DOM）**，该函数将该对象的数据渲染成 `DOM` 树

```js
const objTree = {
    tag: 'div',
    children: [
        { tag: 'span', children: 'hello world' }
    ]
}
function Render(objTree, rootEl) {
    const el = document.createElement(objTree.tag)
    if(typeof children === 'string') { 
        // 文本节点
        const txtNode = document.createTextNode(objTree.children)
        el.appendChild(txtNode)
    } else {
        children.forEach(child => Render(child, el)) // 递归Render
    }
    rootEl.appendChild(el) // 元素添加到Root
}
```

#### 特点

- 手动提供树形结构的数据对象，不灵活，不直观；

#### 框架

`React`

### 编译时 + 运行时 Compiler + Render

```html
<div>
    <span>hello world</span>
</div>
```

经过 `Compiler` 函数编译，将 `HTML` 字符串编译成树形结构的数据对象：

```js
const objTree = {
    tag: 'div',
    children: [
        { tag: 'span', children: 'hello world' }
    ]
}
```

再经过 `Render` 渲染成 `DOM`

#### 特点

- 既支持运行时，用户直接提供树形结构数据对象；也支持编译时，用户提供 `HTML` 字符串经 `Compiler` 编译成树形结构数据对象，运行时经 `Render` 函数渲染成 `DOM`；
- **运行时编译**，代码运行时才开始编译，产生一定==性能开销==，因此将编译放在构建阶段，将内容提前编译好，等到运行时无需编译

#### 框架

`Vue.js 3`

### 纯编译时 Compiler

将 `HTML` 字符串直接编译成==命令式代码==，省去 `Render` 函数的工作

```html
<div>
    <span>hello world</span>
</div>
```

经过 `Compiler` 函数编译，将 `HTML` 字符串直接编译成命令式代码：

```js
const div = document.createElement('div')
const span = document.createElement('span')
span.innerText = 'hello world'
div.appendChild(span)
document.body.appendChild(div)
```

#### 特点

==不支持运行时==，用户代码须经编译才可运行

#### 框架

`Svelte`

### 总结

纯运行时，无法分析用户提供的内容，只在运行阶段才能发现错误（`ts` 与 `js`）；而运行时编译过程中有一定分析空间，可分析哪些内容会变、哪些内容不会变，编译过程🉑提取这些信息；纯编译呢又缺乏一定灵活性，不支持运行时，用户提供的内容必须经过编译才可运行

# Reference
