Created Date：2023-12-19 10:38:13  
Last Modified：2023-12-19 10:38:12

# Tags

[[../../../dev/NPM/Vue2|Vue2]] [[../../../dev/NPM/Vue3|Vue3]] [[../../../前端面经/Vue面经|Vue面经]]

# Content

## 1.1 命令式与声明式

视图层框架通常分为**命令式**和**声明式**。  

1. 命令式框架更加**关注过程**，自然语言描述能够与代码一一对应，代码本身描述的是“做事的过程”，符合我们的逻辑直觉；
2. 声明式框架则**关注结果**，至于实现结果的过程是怎样的，我们并不关心；

```js
// 命令式
const div = document.querySelector('#app') // 获取 div
div.innerText = 'hello world' // 设置文本内容
div.addEventListener('click', () => { alert('ok') }) // 绑定点击事件

// 声明式 Vue：嘿，Vue.js，看到没，我要的就是一个 div，文本内容是 hello world，它有个事件绑定，你帮我搞定吧。
<div @click="() => alert('ok')">hello world</div>
```

## 1.2 性能与可维护性权衡

更新文本命令式代码与声明式代码写法差别：

```js
// 命令式
div.textContent = 'hello vue3' // 直接修改
// 声明式
<!-- 之前： -->
<div @click="() => alert('ok')">hello world</div>
<!-- 之后： -->
<div @click="() => alert('ok')">hello vue3</div>
```

对于框架来说，为了实现最优的更新性能，它需要找到前后的差异并只更新变化的地方，但是最终完成这次更新的代码仍然是：

```js
div.textContent = 'hello vue3'
```

A：直接修改的性能消耗；B：找出差异的性能消耗；则：

- 命令式代码更新性能消耗 = **A**
- 声明式代码更新性能消耗 = **B + A**  

**理想情况**下将 B 降到接近于 0 时，声明式与命令式代码性能消耗相同。

**框架本身封装了命令式代码才向用户提供了声明式，声明式代码的性能不优于命令式代码的性能**。但是声明式代码**可维护性更强，更加直观**，不必像命令式代码那样要维护整个过程，手动完成创建、更新、删除等工作。

框架设计者要做的就是：在保证可维护性的前提下，尽量最小化性能损耗

## 1.3 虚拟 DOM 的性能到底如何

1.2 节提到，声明式代码更新时性能损耗 = B + A，虚拟 DOM 就是为了**最小化 B** 而出现的。 采用虚拟 DOM 更新技术的性能*理论上*不可能比原生 `JavaScript` 操作 DOM 高，因为绝大多数情况下写不出绝对优化的命令式代码。

**纯 JavaScript 层面的操作要比 DOM 操作快得多，它们不在一个数量级上。**

### 创建阶段

虚拟 DOM ：

1. 创建 JavaScript 对象，对真实 DOM 进行描述；
2. 递归地遍历虚拟 DOM 树并创建真实 DOM；  

**创建 JavaScript 对象的计算量 + 创建真实 DOM 的计算量**  

![[Pasted image 20231219111257.png]]  

innerHTML ：

1. 构造一段 HTML 字符串；
2. 赋值给 innerHTML 时，将 HTML 字符串解析为 DOM 树（DOM 层面的计算；

**HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量**

|            | 虚拟 DOM | innerHTML |
| ---------------- | ------- | --------- |
| 纯 JavaScript 计算 |   创建 JavaScript 对象 (VNode)      |     渲染 HTML 字符串      |
| DOM 层面计算                 |     新建所有 DOM 元素    |        新建所有 DOM 元素   |

### 更新阶段

innerHTML：重新构建 HTML 字符串，重新设置 innerHTML 等价于**销毁所有旧的 DOM，再全量创建新的 DOM**；  
虚拟 DOM：重新创建 JavaScript 对象（虚拟 DOM 树），**比较新旧虚拟 DOM，找出变化的元素并更新**；  

|                    | 虚拟 DOM                        | innerHTML                            |
| ------------------ | ------------------------------- | ------------------------------------ |
| 纯 JavaScript 计算 | 创建新的 JavaScript 对象 + diff | 渲染新的 HTML 字符串                 |
| DOM 层面计算       | 必要的 DOM 更新                 | 全量更新！销毁所有旧的，新建所有新的 |
| 性能影响因素       | 与数据变化量相关（无论页面多大只更新变化的内容                | 与页面大小相关（页面越大性能损耗越大                                     |

### 总结

从心智负担、可维护性、性能三方面比较：

![[Pasted image 20231219112721.png]]

## 1.4 运行时和编译时

# Reference
