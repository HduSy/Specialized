Created Date：2024-01-20 15:38:56  
Last Modified：2024-01-20 15:38:56

# Tags

# Content

## 4.1 响应式数据与副作用函数

副作用函数：`effect` 函数的执行，直接或间接影响了其他函数的执行，这时函数产生了副作用  
响应式数据：值发生变化时，相关的 `effect` 函数自动重新执行

## 4.2 响应式数据的基本实现

- 副作用函数执行时，会触发值的读取 `get` 操作
- 设置值时，会触发值的设置 `set` 操作  

副作用函数执行时，涉及值的 `get` 操作，将副作用函数存入“桶”中：  
![[Pasted image 20240123141622.png]]  
设置/更新值时，涉及值的 `set` 操作，将副作用函数从”桶“中取出并执行：  
![[Pasted image 20240123141823.png]]  
代码：

```js
const bucket = new Set(); // 桶
const data = { text: 'Hello World' }; // 原始数据
function effect() {
  document.getElementById('txt').innerText = data.text;
}
new Proxy(data, {
  // 读取操作
  get(target, key) {
    bucket.add(effect); // 加入桶里
    return target[key];
  },
  // 修改操作
  set(target, key, value) {
    target[key] = value;
    bucket.forEach((fn) => fn());
    return true;
  }
});
```

## 4.3 设计一个完善的响应系统

### 全局注册 `activeEffect` 使得不再依赖副作用函数的具体名字

```ts
let activeEffect // 全局变量存储被注册的effect
const bucket = new Set() // 存储副作用函数的“桶”
// 重构4.2节effect函数功能: 注册并执行副作用函数, 相比于硬编码effect名, 支持匿名函数、不同函数名, 不依赖副作用函数的名字了
function installEffect(fn) {
  activeEffect = fn
  fn()
}
const data = { text: 'Hello Vuejs!' } // 原始数据

installEffect(() => {
  document.body.innerText = obj.text
})

const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    if(activeEffect) {
      bucket.add(activeEffect) // effect添加到桶
    }
    return target[key] // 返回属性值
  },
  set(target, key, val) {
    target[key] = val // 设置属性值
    bucket.forEach(fn => fn()) // 取出effect并执行
    return true
  }
})
```

### 🌲树形结构

```ts
effect(function effectFn() {
  document.body.innerText = obj.text
})
// 存在关系
target Proxy代理的目标对象
    └── key 被操作的字段名
        └── effectFn 该值对应的副作用函数
```

- 被操作（读取）的代理对象 `obj`；
- 被操作（读取）的字段名 `text`；
- 使用 effect 函数注册的副作用函数 `effectFn`；

#### 不同副作用函数操作同一属性

```ts
effect(function effectFn1() {
  obj.text
})
effect(function effectFn2() {
  obj.text
})
// 关系结构
target
    └── text
        └── effectFn1
        └── effectFn2
```

#### 同一副作用函数操作不同属性

```ts
effect(function effectFn() {
  obj.text1
  obj.text2
})
// 对应关系
target
    └── text1
        └── effectFn
    └── text2
        └── effectFn
```

#### 不同副作用函数操作不同属性

```ts
effect(function effectFn1() {
  obj1.text1
})
effect(function effectFn2() {
  obj2.text2
})
target1
    └── text1
        └── effectFn1
target2
    └── text2
        └── effectFn2
```

### 实现

**目标：在副作用函数与被操作的目标字段之间建立明确的联系**

```ts
/**
 * 根本原因是，我们没有在副作用函数与被操作的目标字段之间建立明确的联系，拦截了对所有属性的操作！
 * 当读取属性时，无论读取的是哪一个属性，其实都一样，都会把副作用函数收集到“桶”里；
 * 当设置属性时，无论设置的是哪一个属性，也都会把“桶”里的副作用函数取出并执行
 * 设计一个树形结构
 * 同一属性可能对应多个不同的副作用函数；
 * 同一副作用函数可能同时读取了多个树形
 * target --> keys --> effectFns
 */

const bucket2 = new WeakMap()
const obj2 = new Proxy(data, {
  get(target, key) {
    if(!activeEffect) return target[key] // 没有effect直接返回
    let depsMap = bucket2.get(target) // Map: target ---> keys map
    if(!depsMap) bucket2.set(target, depsMap = new Map())
    let deps = depsMap.get(key) // Set: key ---> effectFns set
    if(!deps) depsMap.set(key, deps = new Set())
    deps.add(activeEffect)
    return target[key]
  },
  set(target, key, val) {
    target[key] = val
    const depsMap = bucket2.get(target) // Map: target ---> keys map
    if(!depsMap) return false
    const effectFns = depsMap.get(key) // Set: key ---> effectFns set
    effectFns && effectFns.forEach(fn => fn())
    return true
  }
})
```

![[Pasted image 20240124102159.png]]

## 分支切换与 cleanup

### 什么是分支切换

```js
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, { /* ... */ })

effect(function effectFn() {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```

`effectFn` 副作用函数内部的三元表达式，会根据 `obj.ok` 值的变化执行不同代码分支，**分支切换可能会产生遗留的副作用函数**，**遗留的副作用函数会导致不必要的更新**

`true` 时同时触发 `obj.text` 的 `get`，此时的依赖集合：

```js
data
    └── ok
        └── effectFn
    └── text
        └── effectFn
```

![[Pasted image 20240127101047.png]]  

`false` 时 `obj.text` 不会被读取，只触发 `obj.ok` 的 `get`，**理想情况下**只收集 `obj.ok` 的依赖即可：  
![[Pasted image 20240127101312.png]]  

==按 `4.3` 的实现还实现不了这一点==，`obj.text` 遗留的副作用函数会导致不必要的更新，当 `obj.ok` 由 `true->false` 时，`document.body.innerText` 值始终是 `not`。修改 `obj.text`，对应 `effectFn` 也跟着执行，但此时视图不更新，产生了不必要的副作用执行

### 如何解决分支切换带来的问题

# Reference
